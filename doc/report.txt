
Backlog 2.x
TODO finish writeup

Skapade Fence.java

-- had to move initalisation of final pasture to constructor, due to compiler complaints re constructor type errors
(implicit defintion of constructor w/o arguments??)



Backlog 3.x
Jag började med att byta namn på Dummy till Sheep & lägga till rätt ikon.

Nu känns som att det kommer att bli mycket kodduplikation i de olika klassernas implementationerna av interfacet Entity,
så jag testar att göra om Entity till en abstrakt klass som tillhandahåller defaultimplementationer.

Förflyttning etc. skulle sedan kunna implementeras genom t.ex. ett interface Mobile. Lägger till detta till backlog.

Jag skapade ett interface Mobile som definierar tre metoder, som i princip motsvarar attributen alive, moveDelay & den
version av tick() som fanns i Dummy-klassen under namnet makeMove(). Tanken var att ifrån Entity köra den senare från
tick om entiteten implementerar interfacet Mobile.

Här hoppade jag snart i galen tunna när jag funderade på vad det jag ville uppnå kunde heta i java -- ordet Reflection
fanns i bakhuvudet. Efter att ha läst på lite om reflection api i Java såg jag på flera håll varningar om att det var
en avancerad teknik som sällan behövde användas. I följande kodsnutt försökte jag ta reda om en entitet implementerade
Mobile:

https://gist.github.com/kilskrift/e1b84f4e248ebb3228e3

Vid försök att köra koden med ett anrop till makeMove på objektet fick jag dock följande fel

java: unreported exception java.lang.NoSuchMethodException; must be caught or declared to be thrown

Om man fångar undantaget ser man vid körning att metoderna finns där under Sheep-klassen, men de verkar inte gå att
köra?

...
class Fence
class Sheep
instance of Mobile with class: class Sheep
public void Sheep.makeMove()
public int Sheep.getMoveDelay()
private static java.lang.Object Sheep.getRandomMember(java.util.List)
public boolean Sheep.isAlive()
class Fence
...

Efter lite mer efterforskning hittade jag en bättre (läs: fungerande!) lösningen dold bakom betydelsen av "Reflection
provides a means for invoking methods on a class. Typically, this would only be necessary if it is not possible to cast
an instance of the class to the desired type in non-reflective code." på

http://docs.oracle.com/javase/tutorial/reflect/member/methodInvocation.html

Aha, det räcker att cast:a till rätt typ (Mobile) när man väl vet att det är rätt klass (instance of Mobile) i Entity.

Backlog 3.4

Jag skapade en ny klass Wolf genom att i princip kopiera innehållet i Sheep, men gjorde vargarna dubbelt så snabba.
Därefter var det dags att extrahera gemensamma metoder. Jag testade att använda Refactor/Extract Superclass i mitt IDE,
vilket gav mig en snygg dialogruta där jag kunde välja metoder & attribut att lyfta ut till superklassen. Jag lät de
specifika inställningarna för hastighet (moveDelay) ligga kvar i konstruktorn till Wolf & Sheep, respektive, medan all
annan kod hamnade i Animal.

Troligen får jag lägga till något slags abstrakt strategimetod som anropas från makeMove
till denna för att differentiera hur djuren rör sig i framtiden? Lade in det senare som en task i backlog & commitade,
nöjd med att ha nått mitt releasemål för kraven 1 & 2.

Backlog 4

Jag skapade en ny klass Plant som ärver från Entity. I den skapade jag sedan metoder som likt Mobile's metoder räknar
ner tick tills dess det är dags för plantan att växa. Då skapar den en ny instans i en angränsande ruta i simuleringen.

Attributet alive som används för förflyttning av djur verkar vara onödigt. Utan den borde Mobile kräva färre metoder?

Borde bryta ut ett Interface för "växande"-egenskapen så att Plant fungerar likadant som Mobile i Entity::tick()

Backlog 4.4

När jag tar ut "riktning" för nya plantor gjorde jag en cast till int på uttrycket

(int)(Math.random() * pasture.getFreeNeighbours(this).size())

Här skjöt jag mig först i foten och missade att sätta uttrycket inom parenterser, med följd att jag castade resultatet
 från Math.random() från en double till 0 eller (osannolikt) 1, med följd att det blir samma beteende som tidigare i
 koden. Som tur var provkörde jag direkt & kunde se felet i simuleringen. Som alltid: var försiktig med dina casts :D

Backlog 4.5

I konstruktor för de olika djuren skickar jag med djurens hastighet till Animals konstuktor. Jag upptäckte att den
konstanten måste deklareras som static, eftersom den skickas med i anropet till konstruktorn -- logiskt när man tänker
efter förstås.

Annars var det mest en fråga om att ta bort onödiga metodanrop & snygga upp i koden till Mobile, Animal, se ändringar
i commit på github //TODO länk till commit här.

Backlog 4.6

Interface:t Multiply är rätt likt Mobile till sin uppbyggnad. Plant är på många sätt en analog till Animal, så kanske
vore det tydligare att göra Animal till abstract, för att vara tydlig med att den inte är tänkt att implementera direkt?


Backlog 5

Jag började med att override:a isCompatible i får till att acceptera att får går på gräs. Loggar när de är på samma
plats så länge, när får äter upp växter löser det troligen  problemet med att ikonerna skriver över varandra i GUI.




